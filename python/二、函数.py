# 1、万物皆函数
# 1.1 “Everything is a function”，约翰·麦卡锡 (John McCarthy) 的追随者，把这个作为信仰，他们认为“状态是万恶之源，变换才是宇宙真理”。与之对应的是面向对象编程的 “Everything is an object”。
# 1.2 其实这就是运动的还是静止的哲学问题，静止的是物质，运动的是能量。而我们知道，Albert Einstein爱因斯坦著名质能方程E = mc^2，告诉我们物质和能量是可以相互转换的。从这个角度上来说，everything is a function 还是 object,也就不难理解了。生命的意义，在于确定某个目标的存在（object），实现这个目标（function）。人的空虚感常常源于静止地看待世界，而忽略了运动的本质，生命不息，运动不止。
# 1.3 函数式编程强调的正是“能量”的流动，而不是“物质”的堆积。如果想要改变output,只能改变input,或者改变函数f()本身。衍生出来的解耦思维，可以把大问题拆解成小问题，把复杂拆解成简单。如果某个环节出现问题，可以单独替换这个环节，而不影响整体。

# 2、数学维度
# y = f(x)
# 2.1 自变量x，函数f，因变量y
# 2.2 一元函数，二元函数，多元函数
# 2.3 映射关系：单射，满射，双射
# 2.4 函数的运算：加法，减法，乘法，除法，复合运算
# 2.5 反函数
# 2.6 函数的性质：奇偶性，周期性，单调性，上下界，连续性
# 2.7 函数的图像
# 2.8 初等函数与特殊函数
# 2.9 函数的极限与导数
# 2.10 积分与微分方程
# 2.11 多元函数与偏导数
# 2.12 向量值函数与曲线积分
# 2.13 函数空间与泛函分析
# 2.14 常见函数类型：线性函数，二次函数，指数函数，对数函数，三角函数，反三角函数，超越函数等
# 2.15 应用领域：物理学，工程学，经济学，生物学，计算机科学等
# 看着是不是头大了，编程语言中的函数，其实就是数学中函数的简化版，主要是为了实现代码的复用和模块化设计。编程只是工具，编程水平的高低，决定于对问题的理解和抽象能力，而不只是对语法的熟练程度。

# 3、调用函数
# 3.1 调用函数，看着很高级，实际很好理解。你用锅炒菜，不会从挖矿石冶铁锻造锅开始吧？直接调用锅来炒菜，那么这个锅就是函数，调用锅就是调用函数。参数就是你放进锅里的菜和调料，返回值就是炒好的菜。
# 3.2 常用的内置函数：print(), len(), type(), int(), str(), list(), dict(), set(), range(), input(), sum(), max(), min(), sorted(), map(), filter(), reduce()等。

# 4、定义函数
# 4.1 继续用炒菜的例子，定义函数就是你自己造锅，你要先有个设计图纸（函数名和参数列表），然后去买材料（函数体），最后把锅造好（return返回值）。以后你要炒菜，就可以直接用你自己造的锅了。
# 4.2 定义函数的语法：
def 函数名(参数列表):
    函数体
    return 返回值

# 示例
def 锅(菜, 调料="盐"):
    炒好的菜 = f"炒了{菜}，加了{调料}"
    return 炒好的菜
print(锅("青菜", "酱油")) #输出结果，炒了青菜，加了酱油
#把这个 锅() 函数保存下来 自制锅.py，以后就可以直接调用了。
from 自制锅 import 锅
print(锅("土豆")) #输出结果，炒了土豆，加了盐

# 4.3 参数类型：位置参数，默认参数，可变参数，命名关键字参数，关键字参数。python解释器会按照这个顺序依次匹配参数。可以微调顺序。
# 4.3.1  位置参数：按顺序传递参数
def 位置参数(a, b):
    return a + b
print(位置参数(2, 3)) #输出结果，5
# 4.3.2 默认参数：给参数设置默认值，定义的默认函数是不变的，但是调用的时候可以灵活多变。
def 默认参数(a, b=10):
    return a + b
print(默认参数(5)) #输出结果，15
# 4.3.3 可变参数：传递任意数量的位置参数
def 可变参数(*args):
    return sum(args)  #args是arguments的缩写，表示参数的集合，这个args是一个元组
print(可变参数(1, 2, 3, 4)) #输出结果，10
# 4.3.4 命名关键字参数：指定关键字参数的名称
def 命名关键字参数(*, name, age):  #这里面的*表示后面的参数必须使用关键字传递，简单说就是必须按照 name=xxx, age=xxx 这种形式传递
    return f"{name} is {age} years old"
print(命名关键字参数(name="Bob", age=25)) #输出结果，Bob is 25 years old
# 4.3.5 关键字参数：传递任意数量的关键字参数
def 关键字参数(**kwargs):
    return kwargs  #kwargs是keyword arguments的缩写，表示关键字参数的集合，这个函数返回一个字典
print(关键字参数(name="Alice", age=30)) #输出结果，{'name': 'Alice', 'age': 30}

# 示例：综合使用各种参数类型
def 终极点餐(主食, 小菜="泡菜", *加料, 龙虾=0, **备注):
    # 1. 位置参数：主食
    # 2. 默认参数：小菜
    # 3. 可变参数：加料（打包成元组）
    # 4. 命名关键字：龙虾（必须指定名字）
    # 5. 关键字参数：备注（打包成字典）
    return f"主食：{主食}，小菜：{小菜}，加料：{加料}，龙虾：{龙虾}，备注：{备注}"
print(终极点餐("米饭", "黄瓜", "鸡蛋", "豆腐", 龙虾=2, 口味="微辣", 送餐时间="30分钟内"))
# 输出结果，主食：米饭，小菜：黄瓜，加料：('鸡蛋', '豆腐')，龙虾：2，备注：{'口味': '微辣', '送餐时间': '30分钟内'} 

# 4.4 返回值类型：单个值，多个值，None
# 4.5 充分利用pass,如果def时候还没想好函数体，可以用pass占位，表示什么都不做，等以后再补充。
def 未完成的函数():
    pass    
# 4.6 在交互环境中def函数时候，会有... 提示符，表示函数体还没有结束。回车两次，函数定义结束

# 5、递归函数：函数自己调用自己，先递再归
# 示例
def 递归函数(n):
    if n <= 1:
        return 1
    else:
        return n * 递归函数(n - 1)
print(递归函数(5)) #输出结果，120 (5!)
# 用弹簧类比，向下压（递）：5 -> 4 -> 3 -> 2 -> 1。 向上弹（归）：1 -> 2 -> 6 -> 24 -> 120。
# 递归函数(n)写成 f(n) 更清晰一些。
# f(5)
# = 5 * f(4)
# = 5 * (4 * f(3))
# = 5 * (4 * (3 * f(2)))
# = 5 * (4 * (3 * (2 * f(1))))
# = 5 * 4 * 3 * 2 * 1
# = 5 * 4 * 3 * 2
# = 5 * 4 * 6
# = 5 * 24
# = 120

# 示例
#汉诺塔问题，把n个盘子理解成第n层和上面的n-1层，A、B、C三根柱子理解成起始柱子、中转柱子、目标柱子。三个宏观步骤：
#1. 让路，把上面的 n-1 个盘子从 A 搬到 B，借助 C
#2. 到位，把最下面那个最大的盘子从 A 搬到 C
#3. 重聚，把留在 B 的 n-1 个盘子搬到 C，借助 A
def move(n, a, b, c):
    if n == 1:
        # 如果只有一个盘子，直接从 A 搬到 C
        print(a, '-->', c)
    else:
        # 第一步：把上面的 n-1 个从 a 搬到 b，借助 c
        move(n - 1, a, c, b)
        # 第二步：把最下面那个最大的从 a 搬到 c
        print(a, '-->', c)
        # 第三步：把留在 b 的 n-1 个搬到 c，借助 a
        move(n - 1, b, a, c)
# 调用测试
move(3, 'A', 'B', 'C')
# move(3, A, B, C) 的执行过程：
# 1. [n=3] 把上面2个从 A->B:
#    - A --> C
#    - A --> B
#    - C --> B
# 2. [n=3] 把最下面最大的从 A->C:
#    - A --> C
# 3. [n=3] 把留在 B 的2个从 B->C:
#    - B --> A
#    - B --> C
#    - A --> C
# 最终输出：
# A --> C
# A --> B
# C --> B
# A --> C
# B --> A
# B --> C
# A --> C 

print("老板指挥牛马手册")
# 指令格式：move(盘子数n, 起点a, 中转b, 终点c)
# 当你想搬动 n 个盘子时：
# 1. 【腾地方】：
#    下令给下属：“去，把上面 (n-1) 个盘子从 [起点] 搬到 [中转站]！”
#    (代码：move(n-1, a, c, b) -> 这里的终点变成了b)
# 2. 【干大事】：
#    你自己动手：“我把最底下那个盘子从 [起点] 搬到 [终点]。”
#    (代码：print(a --> c) -> 这是唯一真正打印出来的动作)
# 3. 【大合体】：
#    下令给下属：“去，把刚才停在 [中转站] 的 (n-1) 个盘子挪到 [终点]！”
#    (代码：move(n-1, b, a, c) -> 这里的起点变成了b)
# 【为什么参数位置会变？】
# 因为你下令的时候，任务的目的地变了：
# 第一步：目的是腾出空间，所以[中转站]成了下属的[目的地]。
# 第三步：目的是最后集合，所以[中转站]成了下属的[起点]。
# 【最底层真相】：
# 当 n = 1 时，下属没法再找下属了，只能亲自动手搬。
# 大多数的输出结果，其实都是这些“最底层员工”亲手搬运的记录。

# 用数学的逻辑来描述这个过程：f(n) = f(n-1) + 1 + f(n-1)
# 老板看似只做了1次搬运（把最大的盘子从 A 搬到 C），但实际上他指挥了两次 f(n-1) 的搬运任务（把上面的 n-1 个盘子从 A 搬到 B，再把它们从 B 搬到 C）。
# 这个递归过程可以展开成：
# f(n) = 2*f(n-1) + 1
# = 2*(2*f(n-2) + 1) + 1
# = 4*f(n-2) + 2 + 1
# = 4*(2*f(n-3) + 1) + 2 + 1
# = 8*f(n-3) + 4 + 2 + 1
# ...
# = 2^k * f(n-k) + (2^(k-1) + 2^(k-2) + ... + 2^1 + 1)
# 当 k = n-1 时，f(n-k) = f(1) = 1
# 最终结果是：
# f(n) = 2^(n-1) * 1 + (2^(n-2) + 2^(n-3) + ... + 2^1 + 1)
# = 2^(n-1) + (2^(n-1) - 1)
# = 2^n - 1
# 也就是说，搬 n 个盘子，最少需要搬运 2^n - 1 次，f(n)=2^n - 1。
# 所以啊，劳心者治人，劳力者治于人。递归函数很好地体现了这一点。

# 5、函数式编程
# 函数式编程（Functional Programming，FP）是一种编程范式，强调使用纯函数和不可变数据结构来构建程序，是一种高级抽象方式，距离人的抽象思维近，距离计算机本身的运算方法远。简单说函数式编程，就是关注输入输出的关系，而不是具体的实现过程。python虽然是面向对象的语言，但是支持函数式编程，提供了许多函数式编程的特性和工具。
# 5.1 纯函数：相同的输入，永远得到相同的输出，没有副作用（不修改外部状态，不依赖外部状态）。
def 纯函数(x, y):
    return x + y
# 就好比是个空气炸锅，放进去的东西一样，炸出来的东西就一样，不会因为外部环境变化而变化。而厨师是非纯函数，厨师的心情、体力、经验都会影响菜的味道。
# 5.2 不可变性：数据一旦创建，就不能修改，只能创建新的数据。类似不修改原食材，只出成品，就好比凉拌黄瓜，黄瓜切好了就不能再变回整根黄瓜了，只能重新买一根新的黄瓜，原食材的性质永远不动，得到一份全新的成品。
# 5.3 高阶函数：接受函数作为参数，或者返回函数作为结果。
def 高阶函数(f, x):
    return f(x)
def 平方(n):
    return n * n
print(高阶函数(平方, 5)) #输出结果，25
# 就是厨具，不直接做菜，而是帮助厨师做菜，比如锅、刀、铲子等。
# 5.3.1 map()函数，map是映射，把每个元素映射成新的元素。类比土豆切丁，map(切丁机, 土豆篮子)，把土豆篮子里的每个土豆都切成丁，返回一个新的篮子，里面装满了土豆丁。
土豆篮子 = [1, 2, 3, 4, 5]
def 切丁机(土豆):
    return 土豆 * 土豆
土豆丁篮子 = list(map(切丁机, 土豆篮子))
print(土豆丁篮子) #输出结果，[1, 4, 9, 16, 25]  
# 5.3.2 filter()函数，过滤器，把不符合条件的元素过滤掉。类比洗菜篮，filter(筛子, 菜篮子)，把菜篮子里的坏菜都过滤掉，返回一个新的篮子，里面装满了好菜。
菜篮子 = [1, 2, 3, 4, 5, 6]
def 筛子(菜):
    return 菜 % 2 == 0  #只留下偶数
好菜篮子 = list(filter(筛子, 菜篮子))
print(好菜篮子) #输出结果，[2, 4, 6]
# 5.3.3 reduce()函数，归约，把一组元素归约成一个元素。类比熬汤，把各种食材放进锅里，经过熬煮，最后得到一锅汤。
from functools import reduce
食材篮子 = [1, 2, 3, 4, 5]
def 熬汤(汤, 食材):
    return 汤 + 食材
汤锅 = reduce(熬汤, 食材篮子, 0)  #初始汤是0
print(汤锅) #输出结果，15 (1+2+3+4+5)   
# 5.4 偏函数：固定某些参数，生成新的函数。类比调味料预混合,买的很多调料都是预制好的，把盐和糖预先混合好，生成一个新的调味料包，以后做菜时直接用这个调味料包就行了。
from functools import partial 
def 调味料(盐, 糖, 酱油):
    return f"调味料包：盐={盐}, 糖={糖}, 酱油={酱油}"
预混合调味料 = partial(调味料, 盐=5, 糖=10)  #固定盐和糖
print(预混合调味料(酱油=15)) #输出结果，调味料包：盐=5, 糖=10, 酱油=15    
# 5.5 闭包：函数内部定义函数，内部函数可以访问外部函数的变量。类比厨师的秘密配方，外部函数是厨师，内部函数是配方，配方可以使用厨师的秘密材料。

# 6、模块化
# 函数式编程给了精准的工具，比如切丁机、滤网、熬汤锅等，可以把复杂的烹饪过程拆解成简单的步骤，每个步骤用一个函数来实现。而模块化是给了合理的布局方式，把相关的函数组织在一起，形成一个独立的模块。就好比厨房里的不同区域，切菜区、炒菜区、烤箱区等，每个区域都有专门的工具和材料，方便厨师高效工作。
# 6.1 模块的创建：把相关的函数放在一个.py文件中
# 6.2 模块的导入：使用import语句导入模块
# 6.3 模块的使用：通过模块名.函数名()调用函数
# 6.4 常用模块：math, random, datetime, os, sys, re, json, csv, itertools, functools等
# 6.5 自定义模块：把自己写的函数放在一个.py文件中，方便复用和分享
# 6.6 包的创建：把相关的模块放在一个文件夹中，形成一个包
# 6.7 包的导入：使用import语句导入包
# 6.8 包的使用：通过包名.模块名.函数名()调用函数
# 6.9 常用包：numpy, pandas, matplotlib, requests